\documentclass{acm_proc_article-sp}

\begin{document}

\title{Object-oriented vs Event-based middleware}
\subtitle{[Abstract]}


\numberofauthors{4} 
\author{
\alignauthor
Satarupa Mukherjee \\
       \affaddr{University of Alberta}\\
       \email{satarupa@ualberta.ca}
\alignauthor
Eric Luong \\
       \affaddr{University of Alberta}\\
       \email{eluong@ualberta.ca}
\and  
\alignauthor 
Todd Mortimer \\
       \affaddr{University of Alberta}\\
       \email{rmortime@ualberta.ca}
\alignauthor 
Timo Ewalds\\
      \affaddr{University of Alberta}\\
       \email{tewalds@ualberta.ca}
}


\maketitle
\begin{abstract}

In this survey, we compare Object Oriented Middleware against Event Based Middleware.

\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

[first page]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Technical Overview}

[half page]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Object Middleware}

[one page]

As software systems became distributed, Remote Procedure Calls (RPCs) were developed to facilitate communication between separate applications that need not be located on the same machine.  As described in \cite{Vinoski:2004p8371}, client applications are able to utilise procedures on server applications with RPCs in the same way that they would call regular procedures.  RPCs generally hide the fact that operations are operating in a distributed fashion, making calls to local procedures and remote procedures look the same.

RPCs evolved into Object-oriented middleware (OOM) and gained the benefit of object-oriented concepts such as inheritance, encapsulation, polymorphism, object references and exceptions \cite{Pinus:2006p8367} \cite{Vinoski:2004p8371}.  As many of today's most popular languages are object-oriented, OOM fits in naturally and allows developers to work within a familiar environment.  

OOM uses distributed objects to coordinate processes on multiple hosts.  As with RPCs, OOMs tend to hide the distributed nature of an application.  For example, a client process may have a reference to an object on the server.  As far as the client is concerned, the object is local.  The reference provides method stubs that can be used by the client.  When called, the stubs initiate a network request and take care of the work necessary for network communication, such as the marshalling of parameters.  When the server object finishes its work, a response is sent back in the same way.  

This communication is synchronous, though some OOMs will offer asynchronous communication methods as well.  For example, the Internet Communications Engine (Ice) allows for asynchronous invocation and asynchronous call dispatch \cite{Henning:2004p8372}.  [ELABORATE on what asynch invocation and asynch call dispatch are...?]







%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Event-based Middleware}

[one page]

Event based systems are often alternately referred to as Message Oriented Middleware (MOM) or Publish / Subscribe systems, but they all follow the same basic semantics. In event based middleware systems, entities are typically broken down into producers and consumers. The producers generate events and send them to the consumers, who receive and react to them. The mechanics of how these systems function vary within a wide range, but the functional semantics are typically broken down into three phases:

\begin{description}
\item[Advertisement] The producer indicates what kinds of events or messages they can produce.
\item[Registration] Consumers choose one or many advertisements and indicate what events or messages they would like to be notified of.
\item[Notification] The producers begin sending events to the interested consumers.
\end{description}

Each of these phases can have different levels of abstraction which subsequently inform the qualities of the system In some systems, the advertisement phase is absent completely and consumers must discover event producers through some other mechanism. For example, in a tightly coupled system such as system event notifications on a single host - such as Microsoft's COM+ Events system - information about which event producers are available and which events the produce may simply be listed in programmer documentation. Alternately, the Cambridge Event Architecture (CAE) includes a facility for event producers to be directly queried by consumers for lists of which events they produce and the interface for subscribing to those events \cite{Bacon:2000p6818}. In this system, consumers interact directly with producers to both discover and subscribe to events, and notifications are then delivered directly to those consumers by the producer. If we introduce a layer of indirection between the producer and consumer, an intermediate service may act as a broker between producers and consumers. In this type of system, consumers interact with the broker as they would with the producer directly, and the producer communicates only with the broker. In this way, the producer sends its advertisements to the broker, who then makes those advertisements available to consumers. For example, in the PADRES system multiple brokers form a network through which advertisements are flooded, \cite{Jacobsen:2010p8313}, eventually reaching all the consumers in the system.

Registration and Notification phases can be handled similarly. The consumers can register with the event producer directly, such as in CAE \cite{Bacon:2000p6818}, or they can register with some intermediate entity, such as a broker. Typically, if a consumer registers with a broker then they will also receive notifications through the same broker. While the direct registration and notification system is simpler to conceptualize and build, the layer of abstraction provided by the brokered architecture has advantages for scaling and performance, as the burden of communicating with consumers is moved from the producer to the broker. This performance and scalability concern is significant enough that some event architectures which are primarily designed with direct communications between producers and consumers in mind, such as CAE \cite{Bacon:2000p6818} and Java Message Service (JMS) \cite{Oracle:2002p8432}, have extensions which introduce brokers between consumers and producers which can be leveraged to improve performance on heavily loaded systems.

In addition to different design choices for the mechanics of event advertisement, registration and notification, there is a similar range of choices for the implementation of the events or messages themselves. In tightly coupled systems, messages can be serialized platform specific objects passed between producer and consumer, such as serialized Java Beans in JMS \cite{Oracle:2002p8432}, or objects defined by the programmer through an IDL, such as in CORBA Events \cite{Siegel:1999p8569}. In these instances, some level of system homogeneity is required, in that both producer and consumer must understand object formats and semantics. More loosely coupled systems implement messages as specially formatted strings of ordinary text, and a producer or consumer simply has to understand the format of messages in order to participate in the system. PADRES is an example of such a system where entities interact by passing textual messages to each other \cite{Jacobsen:2010p8313}, and messages simply consist of lists of parameter values formatted into tuples ({\it i.e.,\/ [Param, =, Value]}).

In addition to a spectrum of message formats, there is a spectrum of registration types. In the simplest registration systems, consumers simply register for all events of some type and subsequently receive notifications of all such events. The CORBA Event Service is like this, in that consumers subscribe to some event channel and subsequently receive every event that is posted to that channel . In more complex systems, clients can subscribe to some subset of events by supplying a filter. Filters typically specify some range of event parameter values that the consumer is interested in, and producers or brokers refrain from passing events that do not match that filter to those clients. Most event based middleware supports this kind of filtering, including JMS, CORBA Notifications, CAE and PADRES. More complex still is the composition of events into composite event registrations, in which a consumer registers for an event which is composed of two or more other events. Support for this kind of composite registration is less common, and is complicated if the consumer registers for composite events which are supplied by different producers. CAE and PADRES both support composite event registrations through their brokers, who handle the business of registering for the individual event notifications and then perform the event composition for the consumer. The difference between the two implementations is in the nature of the composing entity: In CAE the Composite Event Service is monolithic and fixed, whereas in PADRES composite events can be processed by any broker in the network and the brokers work together to choose some broker that can perform the event composition with minimal cost in terms of network resources and broker computation resources. In this way, the PADRES composite event implementation scales better than the CAE implementation.

We see then that there is a wide spectrum of event based middleware. System semantics typically follow the advertise / register / notify paradigm, but the details of how each of these phases works can vary between implementations. Communications between consumers and producers can be direct or mediated by brokers, with resultant effects on performance and scalability. Events and messages themselves can be implemented in both platform dependent or platform independent ways, and the mechanism for achieving platform independence can be either through some shared specification, such as when IDLs are used, or simply through the use of plain text messages which are parsed by system entities. Finally, event registrations or subscriptions can range from the simplistic type where all events produced are simply consumed, to the more sophisticated type where events can be filtered out based on consumer preferences, to the very complex where events from different producers can be composed together by system intermediaries and delivered to consumers who have registered for these composite events. While we have largely confined ourselves here to the JMS, CAE, CORBA and PADRES implementations of event or message based middleware, there exist many more implementations, some of which are surveyed by Tarkoma {\it etal.\ } in \cite{Tarkoma:2006p6862}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Time, Space and Synchronization}


Middleware is meant for communication between systems, though they vary in a few ways. One of the big distinctions between categories of middleware is how the endpoints are coupled. The main 3 ways that the endpoints can be coupled is in time, space and synchronization. Highly coupled systems appear to be local and are easier to reason about, but are not scalable. Decoupling can be achieved along these 3 axes:

\begin{description}
\item[Time decoupling] The endpoints need not be available at the same time. Messages can be buffered in the middleware and received at a later time, even if the sender is no longer available.
\item[Space decoupling] The endpoints need not know who is sending or receiving the messages. It may even be multiple receivers.
\item[Synchronization decoupling] The endpoints need not wait for each other to process the messages or send a response.
\end{description}

Given these definitions, we analyze where object-oriented middleware and event-based middleware fit into the spectrum.

Object-oriented middleware is often used as Remote Procedure Calls (RPC). To disguise the fact that it is a remote call, it must be coupled in time and be synchronous. An error will occur if the other endpoint is unavailable or if it is very slow to reply. Most Object-oriented middleware would be considered coupled in space, though some object-oriented middleware uses a lookup service to establish a connection with the other endpoint. In those cases they would be partially coupled due to still communicating directly with the other endpoint. When sending an asynchronous notification, the middleware would be considered partially synchronous. The sender need not wait for the receiver, but the receiver must process the message immediately.

Many event-based middleware implementations attempt to be fully decoupled for maximum scalability. Some event-based middleware, such as CAE are only partially decoupled in time and space, while enforcing synchronization decoupling, but most of them introduce a broker to handle the decoupling. The broker can buffer messages locally to allow messages be received despite being offline when the publisher sent the message or the publisher being offline when it is received. The broker delivers the messages to all interested parties, allowing the publisher to be oblivious to the recipient. When there are many interested recipients, the broker can distribute the message more efficiently than if the publisher had to send the message to each recipient directly. 

%aka. Buffered / Direct / [A]Synchronous

%[one page]

% 
% I mean the whole middleware thing is defined by whether they are coupled by space, time and synchronization, and who gets the messages. Object oriented is just a group of points in those coordinates, event-based is some other group of points, pub/sub is another set of points
% 
% If we set it up with discussions of obj and the bag of eb middleware, then we can lead into the discussion of the time / space / sync question, and then distinguish what we've already discussed in those terms. We could even talk about applications matching points in that space, which makes them more or less appropriate for different systems
% 
% I think it is good to start with what is expected (Objects here, Events there) and then pull out the spectrum synthesis later
% 
% then we'll discuss applications and how the apps we see fit into the spectrum
% and then why the application coordinates are close to the system coordinates
% 
% Hmm, how would you define event-based middleware? Is the defining point that it is 1:n, or that it is async? or something else?
%
% for me, the defining characteristics are data-centricity and async
% 1:n is a byproduct of the fact that its data centric and not object / host centric
% in an obj system, there's only one object that you talk to (that provides some service or whatever), and you need it to do something. data centric services make distribution to multiple interested parties natural
% 
% I'm trying to figure out the defining points of each of these
%
% what defines object middleware and what defines event middleware?
%
% yeah
% 
% 
% can you explain your three axis to me? I want to put it into an email to the others to give context to the changes / synthesis. I think they'll be happy, because it's a nice package
% so time, space, sync.
% 
% what do you mean by time?
% 
% time essentially means the two machines that are interacting don't need to be even online at the same time. The messages are buffered in the middleware.
% 
% okay. space?
% 
% the two machines don't need to know about each other, they interact by something other than direct references but instead by interest
% 
% okay. and sync?
% 
% synchronization means the machines never block waiting on a response from the other
% the only one that's a little fuzzy is space, but we just have to be clear about what we're talking about. 
% 
% do you think there are any other axis? 
% 
% well, he also defines the axis of interest, but I'm not sure those are orthogonal to the previously defined axis
% 
% nah, I would argue that interest isn't in the same system. Interest is what the system is, time/space/sync is how the system is. object system have interests the same as event systems. they just work differently. that's what discovery services are for
% 
% are these three orthogonal?
% 
% I would say.. can you have x>0 on one and y=z=0 on the others? can we hold sync and space constant while varying time?
% 
% that would effectively just be a really slow connection
% you can be sync, in that you wait until the other guy comes back online
% 
% It may be easier to think of these as buffered, direct and sync
% 
% you can be buffered and direct, in the sense that you know who your end point is, but not have a direct link
% 
% I suppose you could also think of this as where do you put your layer of abstraction.
% 
% that's pretty much what the whole course is about...
% 
% This is a start:
% buffer | direct | sync
% false  | false  | false => fire and forget, only to online hosts : irc
% false  | false  | true  => 
% false  | true   | false => corba notifications
% false  | true   | true  => RPC
% true   | false  | false => event based messages : PADRES
% true   | false  | true  => useless? wait forever
% true   | true   | false => must be buffered locally, distributed event-based
% true   | true   | true  => very slow RPC


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Applications}

\subsection{Object Oriented Middleware}

[one page for object applications, how they fit in the spectrum]


\subsubsection{Killer App}

[half page - why object based is particularly well suited to some kind of application, where are we in the spectrum?]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Achilles Heel}

[half page - what do obj systems do not so well, why?]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Event Based Middleware}
[one page for event applications, how they fit in the spectrum]

- anything that is loosely coupled\\
- anything asynchronous\\
- anything that must be scalable\\
\\
- event notifications on OSX/windows\\
- broadcasting updates (stocks, news, twitter)\\
- communication (irc, xmpp, email)\\
- sensor networks\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Killer App}

[half page - why event based is particularly well suited to some kind of application, where are we in the spectrum?]

Event-based middleware is well suited to any application where the components are loosely coupled and can work asynchronously, particularly if they don't know or don't need to know the exact origin or destination of their messages.

Email is one of the earliest examples, and easily the most used of the event based systems. Email is a very scalable architecture, handling about 300 billion messages per day. It is based on a broker network of Simple Mail Transfer Protocol (SMTP) servers. Each server advertises a set of domains that it handles by the MX tag in DNS. Users write and send messages using an email client, but these clients are not part of the broker network itself.

Messages are sent by a user to their outgoing SMTP server synchronously, but the final delivery is asynchronous. This first SMTP server attempts to locate the next destination and forwards the message. If the destination is a local address, then it is simply delivered. If the next server is down, it is buffered locally for later delivery. If the next server rejects the message, then it is bounced back to the sender, to be noticed at a later date. If the next server accepts the message, the process starts over from there, until it has reached the final destination. The sender and recipient are decoupled in time, since the message could be delivered to a recipient who is offline at the time of sending, and the sender can be offline at the time of arrival.

While an email address appears to be a specific address, it is actually closer to a fairly broad subscription in the publish/subscribe model. A mailing list is nothing more than an email address that is associated with multiple recipients. Many mailing lists allow arbitrarily many people to subscribe to that address, again similar to subscriptions in the publish/subscribe model. Other addresses are forwarded to many devices, such as a desktop, laptop, and mobile phone, showing that even if an address is only associated with a single user, it may be associated with multiple devices. SPAM would not be nearly such a big problem if the subscription wasn't so broad.

Email is a well known, well used and very scalable event-based system. Messages are sent asynchronously and are buffered in the broker network, while the final recipient of each message is only loosely related to the destination address. These are the main attributes of an event-based middleware.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Achilles Heel}

[half page - what do event systems do not so well, why?]

Event-based middleware is not suited to applications that follow the request/response model. There are rarely guarantees of delivery  at all, since it is unknown whether there is actually an interested recipient for each message. There is also no guarantee of latency. If a message can be buffered in the broker network until an interested recipient arrives, it could be months before a given message is processed. Together these make event-based middleware inapplicable to situations where synchronous operation is desirable.

As an example of the consequences of this model, let us imagine that HTTP was replaced by PADRES. HTTP is a request/response protocol. It is generally unbuffered and synchronous, with a destination known at request time. There are limited advertisements of availability or subscriptions of interest.

Assume, like today, there are billions of websites all interacting on PADRES. Instead of domains and urls there are advertisements of content types and publications of content. There would be no need for Google or other search engines since it would be handled implicitly by PADRES and subscriptions. Websites would not need many servers since all previously published content would be buffered on brokers in the middleware for later delivery.

Imagine you want to buy a laptop, so you do a search for "laptop". Instead of getting a page with 10 listings, some leading to definitions, some to reviews, some to places to buy, you'd get a flood of all content that has ever been produced that mentioned laptops. If you limit your search to only new content, you'd still get a flood of content that is unlikely to be interesting. If you limit your search even more so it is now only new articles about buying the very specific brand of laptop you are interested in buying, it may take days for anyone to publish anything new that you are interested in, making it quite useless for you to get information. If now you publish a message saying you are looking to buy that specific brand of laptop, your message is freely available to anyone on the network to subscribe to and therefore to reply to. In order to maximize profit it is quite likely that dozens of companies that sell that brand and model, or even similar ones will publish a response, many of which would fit your subscription, again flooding you with information that you didn't want.

If you want a timely response from a specific other party or an error if that other party is offline or unreachable, event-based middleware is totally inappropriate as the foundation of your communications.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusions}

[half page]

% bib should be about a half page with 10 citations
\bibliographystyle{abbrv}
\bibliography{local}

\balancecolumns

\end{document}
